ALTER  FUNCTION [dbo].[fn_G_array2]
(
	@index1 INT,            ----第一层索引  1234
	@index2 INT,            ----第二层索引  1234
	@orgStr VARCHAR(2048)  ----原始数组
)
RETURNS VARCHAR(2048)
AS
BEGIN
	declare @t_array1 varchar(1024) ---一维数组
	---格式化
	set @orgStr = left(@orgStr,len(@orgStr)-2)
	set @orgStr = right(@orgStr,len(@orgStr)-2)
	set @orgStr = replace(@orgStr,'],[','&')
	set @t_array1 = dbo.fn_G_new(@index1,@orgStr,'&')
	set @t_array1 = dbo.fn_G_new(@index2,@t_array1,',')
	RETURN @t_array1
END

ALTER  FUNCTION [dbo].[fn_G_new]
( @index INT, --- 取第i个元素
  @str varchar(2000) ---要分割的字符串
  ,@part varchar(10) ---分隔符
  ) 
  RETURNS VARCHAR(512)
  as
  begin
	
	DECLARE @tmpIdx INT ,@iPostion INT 
	SET @tmpidx=0
	SET @iPostion=0
	SET @str=LTRIM(rtrim(@str)) 	 ---去掉前后空格，保护一下
	if @index=0 return null
	---获取第【i-1】个分隔胡的位置
	WHILE @tmpidx<@index BEGIN 
		IF @tmpidx<>0 and @iPostion=0 BEGIN
			return null
		END
		SET @iPostion=0
		SET @iPostion=CHARINDEX(@part,@str)
		SET @tmpidx=@tmpidx+1
		
		IF @tmpidx=@index BEGIN
			IF @iPostion=0
				RETURN  @str
			ELSE 
				RETURN  LEFT(@str,@iPostion-1)
		END  ELSE BEGIN
			SET @str=RIGHT(@str,LEN(@str)-@iPostion)

		END 
	END 
	
	RETURN  @str
	
  end
  
  
  
  
  
  
  
  
  
  
  
  
  
  ALTER  FUNCTION [dbo].[fn_U_array2]
(
	@index1 INT,            ----第一层索引  1234
	@index2 INT,            ----第二层索引  1234
	@orgStr VARCHAR(2048),  ----原始数组
	@unStr VARCHAR(1024)    ----被修改的值  
)
RETURNS VARCHAR(2048)
AS
BEGIN
	declare @t_array1 varchar(1024), @orgStrT varchar(2048)=@orgStr---一维数组
	---格式化
	set @orgStr = left(@orgStr,len(@orgStr)-2)
	set @orgStr = right(@orgStr,len(@orgStr)-2)
	set @orgStr = replace(@orgStr,'],[','&')
	set @t_array1 = dbo.fn_G_new(@index1,@orgStr,'&')
	if isnull(@t_array1,'')='' return @orgStrT
	set @t_array1 = dbo.fn_U_new(@index2,@t_array1,@unStr,',')
	set @orgStr = dbo.fn_U_new(@index1,@orgStr,@t_array1,'&')
	set @orgStr = replace(@orgStr,'&','],[') 
	set @orgStr = '[['+@orgStr+']]' 
	RETURN @orgStr
END


ALTER  FUNCTION [dbo].[fn_U_New]
(
	@index INT,            ----拼入到那个索引节点（索引元素）
	@orgStr VARCHAR(2000), ---待拼接前的原始字符串
	@unStr VARCHAR(2048)   ----需要被拼入的字符串
	,@part varchar(10)  ---分隔符
)
RETURNS VARCHAR(2000)
AS
BEGIN
	--return @orgStr
	DECLARE @tmpIdx INT ,@iStart INT ,@iEnd INT ,@StrLen INT ,@retStr VARCHAR(2000)
	SET @tmpidx=0
	SET @iStart=0
	SET @iEnd=0
	SET @orgStr=LTRIM(rtrim(@orgStr)) 	 ---去掉前后空格，保护一下
	SET @StrLen=LEN(@orgStr)
	set @unStr = case when isnull(@unStr,'')='' then '' else @unStr end  ---保护一下

--	declare @a table (id int,item nvarchar(256))
--	insert into @a(id,item)
--	select * from mtAppMahjong.dbo.fn_Split(@orgStr,'|')

--	--select * from @a

--	update @a set item=@unStr where id=@index

----	set @orgStr=''
--	select @retStr=isnull(@retStr,'')+'|'+isnull(item,'') from @a order by id
--	--select * from @a
--   set @retStr=right(@retStr,len(@retStr)-1)
--	--select @orgStr
--		RETURN @retStr



	---获取第【i-1】个分隔胡的位置
	WHILE @tmpidx<@index BEGIN 
		SET @iStart=@iEnd
		SET @iEnd=CHARINDEX(@part,@orgStr,@iStart+1)
		
		IF @iEnd=0 BEGIN 
			SET @iEnd=@StrLen+1
			BREAK
		END 
		
		SET @tmpidx=@tmpidx+1
	END 		

	IF @iEnd<=@StrLen
		SET @retStr=SUBSTRING(@orgStr,1,@iStart)+@unStr+SUBSTRING(@orgStr,@iEnd,@StrLen)
	ELSE 
		set @retStr=SUBSTRING(@orgStr,1,@iStart)+@unStr
		
	RETURN @retStr
END

